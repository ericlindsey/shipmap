<!DOCTYPE html>
<html>
<head>
  <title>Ship Track Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body { margin: 0; padding: 0; }
    #map { height: 100vh; }
  
    .ship-marker {
      transition: transform 0.2s ease;
    }

    .flip-horizontal {
      transform: scaleX(-1);
    }

    .circle-label {
      font-size: 12px;
      font-weight: bold;
      color: navy;
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      white-space: nowrap;
      box-shadow: none;
    }

    .speed-control {
      background: white;
      padding: 6px;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0,0,0,0.2);
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src=" https://unpkg.com/@joergdietrich/leaflet.terminator@1.0.0/L.Terminator.js"></script>

<script>
  let map;
  let trackLine; // Keep reference to the existing polyline
  let shipMarker; // Live ship position marker
  let terminator;
  let shipPosition = null;
  let shipSpeedKnots = 13;
  let rangeCircleLayer = L.layerGroup();

  function getShipIcon(isEastbound = true) {
    return L.divIcon({
      className: '', // disable default Leaflet styling
      html: `<div class="ship-marker ${isEastbound ? 'flip-horizontal' : ''}" style="background-image: url('/static/ship_icon.png'); width: 32px; height: 32px; background-size: contain; background-repeat: no-repeat;"></div>`,
      iconSize: [32, 32],
      iconAnchor: [16, 16]
    });
  }

  async function fetchTrack() {
    try {
      const response = await fetch('/get_track_data');
      if (!response.ok) throw new Error(`Server error ${response.status}`);
      const data = await response.json();
      return data.track;
    } catch (error) {
      console.error("Error fetching track:", error);
      return [];
    }
  }

  function updateRangeCircles() {
    if (!shipMarker) return;
  
    rangeCircleLayer.clearLayers(); // remove old rings + labels
  
    const center = shipMarker.getLatLng();
    const hours = [6, 12, 24];
    const metersPerKnotPerHour = 1852;
  
    for (const h of hours) {
      const radiusMeters = shipSpeedKnots * h * metersPerKnotPerHour;
  
      // 1. Add the circle
      const circle = L.circle(center, {
        radius: radiusMeters,
        color: 'blue',
        fill: false,
        weight: 1,
        dashArray: '4,4'
      });
      rangeCircleLayer.addLayer(circle);
  
      // 2. Add a label marker just north of the circle
      const labelLatLng = L.latLng(
        center.lat + (radiusMeters / 1000) / 111.32, // 1 deg â‰ˆ 111.32 km
        center.lng
      );
  
      const label = L.marker(labelLatLng, {
        icon: L.divIcon({
          className: 'circle-label',
          html: `<div>${h}h</div>`,
          iconSize: [30, 12],
          iconAnchor: [15, 6]
        }),
        interactive: false // prevents hover/click effects
      });
  
      rangeCircleLayer.addLayer(label);
    }
  }

  async function updateTrack() {
    const track = await fetchTrack();
    if (track.length === 0) return;

    const latlngs = track.map(p => [p.lat, p.lng]);

    // Remove previous line if it exists
    if (trackLine) {
      map.removeLayer(trackLine);
    }

    // Draw new line
    trackLine = L.polyline(latlngs, { color: 'red' }).addTo(map);

    // Optional: zoom to new track
    //map.fitBounds(trackLine.getBounds());

    // Get last point for ship position
    const lastPoint = latlngs[latlngs.length - 1];
    shipPosition = L.latLng(lastPoint);

    // flip the icon if the ship is moving east
    const prev = latlngs[latlngs.length - 2];
    
    // Determine ship direction
    const isEastbound = lastPoint[1] > prev[1]; // comparing longitudes
  
    // Add or move ship marker
    if (!shipMarker) {
      shipMarker = L.marker(lastPoint, {
        icon: getShipIcon(isEastbound),
        title: "Current Position"
      }).addTo(map);
    } else {
      shipMarker.setLatLng(lastPoint);
      shipMarker.setIcon(getShipIcon(isEastbound));
    }
    updateRangeCircles();


  }

  async function loadWaypoints() {
    const response = await fetch('/get_waypoints');
    if (!response.ok) {
      console.error("Failed to load waypoints");
      return;
    }
  
    const text = await response.text();
    const lines = text.trim().split('\n');
  
    for (const line of lines) {
      const parts = line.split(',');
      if (parts.length < 2) continue;
  
      const lat = parseFloat(parts[0].trim());
      const lng = parseFloat(parts[1].trim());
      const label = parts[2] ? parts[2].trim() : 'Waypoint';
  
      const waypointLatLng = L.latLng(lat, lng);
  
      const marker = L.marker(waypointLatLng, {
        title: label
      });
      
      // Bind empty popup once
      marker.bindPopup('Loading ETA...');
      
      marker.on('click', () => {
        if (!shipPosition || shipSpeedKnots <= 0) {
          marker.setPopupContent(`${label}<br>ETA: Unknown`);
        } else {
          const distanceMeters = shipPosition.distanceTo(waypointLatLng);
          const distanceNauticalMiles = distanceMeters / 1852;
          const hours = distanceNauticalMiles / shipSpeedKnots;
      
          const etaH = Math.floor(hours);
          const etaM = Math.round((hours - etaH) * 60);
      
          marker.setPopupContent(`${label}<br>ETA: ${etaH}h ${etaM}m`);
        }
      
        marker.openPopup();
      });
      
      marker.addTo(map);
    }
  }

async function initMap() {
  map = L.map('map').setView([0, 0], 3);

  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const bathyLayer = L.tileLayer.wms('https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?', {
    layers: 'GEBCO_LATEST',
    format: 'image/png',
    transparent: true,
    attribution: '&copy; GEBCO 2023',
    opacity: 0.5
  });

  rangeCircleLayer.addTo(map);

  // Create the day/night terminator layer
  terminator = L.terminator();

  // Update terminator every 5 min
  setInterval(() => {
    if (terminator) {
      terminator.setTime(new Date());
      terminator.redraw();
    }
  }, 5 * 60 * 1000);

  // Layer controls
  const baseMaps = {
    "OpenStreetMap": osm
  };

  const overlayMaps = {
    "GEBCO Bathymetry": bathyLayer,
    "Day/Night Terminator": terminator,
    "Distance Rings": rangeCircleLayer
  };

  L.control.layers(baseMaps, overlayMaps).addTo(map);

  new L.Control.SpeedInput({ position: 'topright' }).addTo(map);

  // Set initial speed from input box
  shipSpeedKnots = parseFloat(document.getElementById('speedInput').value);

  // Watch for speed changes and update rings
  document.getElementById('speedInput').addEventListener('input', () => {
    shipSpeedKnots = parseFloat(document.getElementById('speedInput').value);
    updateRangeCircles();
  });

  // Load track + ship marker
  await updateTrack();

  // Load waypoints
  await loadWaypoints();

  // Refresh track every 5 min
  setInterval(updateTrack, 5 * 60 * 1000);
  setInterval(loadWaypoints, 5 * 60 * 1000);
}


  L.Control.SpeedInput = L.Control.extend({
    onAdd: function (map) {
      const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control speed-control');
  
      container.innerHTML = `
        <label style="font-size: 12px; display: block; text-align: center;">
          Speed<br>
          <input id="speedInput" type="number" value="13" step="0.1" min="0" style="width: 50px; text-align: center;" />
          <div style="font-size: 10px;">knots</div>
        </label>
      `;
  
      // Prevent map from zooming when interacting with input
      L.DomEvent.disableClickPropagation(container);
      return container;
    },
  
    onRemove: function (map) {
      // Nothing to do here
    }
  });

  initMap();

</script>
</body>
</html>
